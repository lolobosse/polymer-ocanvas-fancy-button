<link rel="import"
      href="bower_components/polymer/polymer.html">
<script src="bower_components/gsap/src/uncompressed/TweenMax.js"></script>
<script src="bower_components/gsap/src/uncompressed/plugins/CSSPlugin.js"></script>
<script src="libs/ocanvas-2.8.2.min.js"></script>

<dom-module id="my-fancy-button">

    <template>
        <p id="paragraph">I'm a DOM element. This is my local DOM!</p>
        <canvas width="900" height="300" id="canvas"></canvas>
    </template>


    <script>
        var canvas;
        var rectangle;
        var text;
        var sideRectangles = [];
        var gold = "#dec275";
        var white = "#fff";
        var lines = [];
        var strokeWidth = "3px ";
        var percentOfRectangleForMargin;
        var timeOfLastCalled = new Date().getTime();

        Polymer({
            is: "my-fancy-button",
            ready: function () {
                buildCanvas();
            }
        });

        function buildContainerRectangle() {
            rectangle = canvas.display.rectangle({
                x: canvas.width / 2,
                y: canvas.height / 2,
                fill: "#333",
                origin: {x: "center", y: "center"},
                width: canvas.width / 2,
                height: canvas.height / 2
            }).add();
        }
        function buildText() {
            text = canvas.display.text({
                text: "This is a text",
                fill: "#fff",
                width: canvas.width / 6,
                height: canvas.height / 6,
                origin: {x: "center", y: "center"},
                x: canvas.width / 2,
                y: canvas.height / 2
            }).add();
        }

        function changeTextColor(isHover) {
            text.fill = isHover ? gold : white;
            canvas.redraw();
        }

        function changeSideRectangleColor(isHover) {
            sideRectangles.map(function (element) {
                element.fill = isHover ? gold : white;
            });
            canvas.redraw();
        }
        function mouseLeave() {
            changeTextColor(false);
            changeSideRectangleColor(false);
        }

        function animateEnter() {
            var baseDuration = 170;
            lines.map(function(line){
                var hLineProperties = line.line1;
                var vLineProperties = line.line2;
                var hLine = canvas.display.line({
                    start: {x: hLineProperties.start.x, y: hLineProperties.start.y},
                    end: {x: hLineProperties.start.x + 1, y: hLineProperties.start.y},
                    stroke: strokeWidth + gold
                }).add();
                var vLine;
                hLine.animate({
                            end: {x: hLineProperties.end.x, y: hLineProperties.end.y}
                        }, {
                            duration: baseDuration,
                            easing: "ease-in-out-quart",
                            callback: function () {
                                // Start other line animation
                                vLine = canvas.display.line({
                                    start: {x: vLineProperties.start.x, y: vLineProperties.start.y},
                                    end: {x: vLineProperties.start.x, y: vLineProperties.start.y + 1},
                                    stroke: strokeWidth + gold
                                }).add();
                                vLine.animate({end:{x: vLineProperties.end.x, y: vLineProperties.end.y}}, {duration: baseDuration * 2});
                                // Start to remove the line
                                hLine.animate({start: {x: hLineProperties.end.x, y: hLineProperties.end.y}}, {
                                    duration: baseDuration * 2,
                                    callback: function () {
                                        // Remove vertical line
                                        vLine.animate({start:{x:vLineProperties.end.x, y:vLineProperties.end.y}},{
                                            duration: baseDuration/1.5
                                        });
                                    }
                                })
                            }
                        }
                )
            });
        }
        function mouseEnter() {
            changeTextColor(true);
            changeSideRectangleColor(true);
            if (new Date().getTime() - timeOfLastCalled > 500) {
                animateEnter();
                timeOfLastCalled = new Date().getMilliseconds();
            }
        }
        function bindListeners() {
            rectangle.bind("mouseenter", mouseEnter);
            rectangle.bind("mouseleave", mouseLeave);
            text.bind("mouseenter", mouseEnter);
            text.bind("mouseexit", mouseLeave);
            sideRectangles.map(function (sideRectangle) {
                sideRectangle.bind("mouseenter", mouseEnter);
                sideRectangle.bind("mouseleave", mouseLeave);
            })
        }
        function buildSideRectangles() {
            sideRectangles[0] = canvas.display.rectangle({
                fill: "#fff",
                width: canvas.width / 100,
                height: canvas.height / 5,
                origin: {x: "center", y: "center"},
                y: canvas.height / 2,
                x: rectangle.x - ((0.85) * 0.5 * rectangle.width)
            }).add();
            sideRectangles[1] = canvas.display.rectangle({
                fill: "#fff",
                width: canvas.width / 100,
                height: canvas.height / 5,
                origin: {x: "center", y: "center"},
                y: canvas.height / 2,
                x: rectangle.x + ((0.85) * 0.5 * rectangle.width)
            }).add();
        }
        function createHorizontalLine(percentOfRectangleForMargin, isTop, isRight) {
            var yOfTopLine = rectangle.y + (isTop ? -percentOfRectangleForMargin : +percentOfRectangleForMargin);
            return canvas.display.line({
                start: {x: rectangle.x, y: yOfTopLine},
                end: {x: sideRectangles[isRight ? 1 : 0].x, y: yOfTopLine},
                stroke: strokeWidth + white
            }).add();
        }
        function createHorizontalLineBoundaries(percentOfRectangleForMargin, isTop, isRight) {
            var yOfTopLine = rectangle.y + (isTop ? -percentOfRectangleForMargin : +percentOfRectangleForMargin);
            return {
                start: {x: rectangle.x, y: yOfTopLine},
                end: {x: sideRectangles[isRight ? 1 : 0].x, y: yOfTopLine},
            }
        }

        function createVerticalLine(percentOfRectangleForMargin, isTop, isRight) {
            var yOfTopLine = rectangle.y + (isTop ? -percentOfRectangleForMargin : +percentOfRectangleForMargin);
            var usedSideRectangle = isRight ? 1 : 0;
            var halfOfSideRectangleSide = (1 / 2) * sideRectangles[1].height;
            var offset = isTop ? -halfOfSideRectangleSide : halfOfSideRectangleSide;
            return canvas.display.line({
                end: {x: sideRectangles[usedSideRectangle].x, y: sideRectangles[usedSideRectangle].y + offset},
                start: {x: sideRectangles[usedSideRectangle].x, y: yOfTopLine},
                stroke: strokeWidth + white
            }).add();
        }

        function createVerticalLineBoundaries(percentOfRectangleForMargin, isTop, isRight) {
            var yOfTopLine = rectangle.y + (isTop ? -percentOfRectangleForMargin : +percentOfRectangleForMargin);
            var usedSideRectangle = isRight ? 1 : 0;
            var halfOfSideRectangleSide = (1 / 2) * sideRectangles[1].height;
            var offset = isTop ? -halfOfSideRectangleSide : halfOfSideRectangleSide;
            return {
                start: {x: sideRectangles[usedSideRectangle].x, y: yOfTopLine},
                end: {x: sideRectangles[usedSideRectangle].x, y: sideRectangles[usedSideRectangle].y + offset}
            }
        }

        function buildLines() {
            percentOfRectangleForMargin = (0.35) * rectangle.y;
            var offsetToSideRectangle = 0.00;
            var yOfTopLine = rectangle.y - percentOfRectangleForMargin;
//            var tempArc = canvas.display.arc({
//                x: tempLine.end.x -1,
//                y: tempLine.end.y,
//                origin : {x:"center", y: "top"},
//                width: sideRectangles[1].x -tempLine.end.x,
//                start: -90,
//                end: 0,
//                radius: 12,
//                stroke: "2px " + white
//            }).add();
            lines[0] = {line1: createHorizontalLineBoundaries(percentOfRectangleForMargin, true, true), line2: createVerticalLineBoundaries(percentOfRectangleForMargin, true, true)};
            lines[1] = {line1: createHorizontalLineBoundaries(percentOfRectangleForMargin, false, true), line2: createVerticalLineBoundaries(percentOfRectangleForMargin, false, true)};
            lines[2] = {line1: createHorizontalLineBoundaries(percentOfRectangleForMargin, true, false), line2: createVerticalLineBoundaries(percentOfRectangleForMargin, true, false)};
            lines[3] = {line1: createHorizontalLineBoundaries(percentOfRectangleForMargin, false, false), line2: createVerticalLineBoundaries(percentOfRectangleForMargin, false, false)};


        }
        function buildCanvas() {
            canvas = oCanvas.create({canvas: "#canvas", background: "#222"});
            buildContainerRectangle();
            buildText();
            buildSideRectangles();
            buildLines();
            bindListeners();
        }
    </script>

</dom-module>